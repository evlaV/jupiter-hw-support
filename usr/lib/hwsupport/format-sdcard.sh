#!/bin/bash

set -e

MOUNT_LOCK="/var/run/sdcard-mount.lock"
SDCARD_DEVICE="/dev/mmcblk0"
SDCARD_PARTITION="/dev/mmcblk0p1"
RUN_VALIDATION=1
EXTENDED_OPTIONS="nodiscard"

while [[ $# -gt 0 ]]; do
    case "$1" in
        --force) RUN_VALIDATION=0; shift ;;
        --skip-validation) RUN_VALIDATION=0; shift ;;
        --full) EXTENDED_OPTIONS="$EXTENDED_OPTIONS,discard"; shift ;;
        --quick) EXTENDED_OPTIONS="$EXTENDED_OPTIONS,nodiscard"; shift ;;
        *) echo "Unknown option $1"; exit 22;;
    esac
done

if [[ ! -e "$SDCARD_DEVICE" ]]; then
    exit 19 #ENODEV
fi

systemctl stop sdcard-mount@mmcblk0p1.service

# lock file prevents the mount service from re-mounting as it gets triggered by udev rules
on_exit() { rm -f -- "$MOUNT_LOCK"; }
trap on_exit EXIT
echo $$ > "$MOUNT_LOCK"

# Test the sdcard
# Some fake cards advertise a larger size than their actual capacity,
# which can result in data loss or other unexpected behaviour. It is
# best to try to detect these issues as early as possible.
if [[ "$RUN_VALIDATION" != "0" ]]; then
    echo "stage=testing"
    if ! f3probe --destructive "$SDCARD_DEVICE"; then
        # Fake sdcards tend to only behave correctly when formatted as exfat
        # The tricks they try to pull fall apart with any other filesystem and
        # it renders the card unusuable.
        #
        # Here we restore the card to exfat so that it can be used with other devices.
        # It won't be usable with the deck, and usage of the card will most likely
        # result in data loss. We return a special error code so we can surface
        # a specific error to the user.
        echo "stage=rescuing"
        echo "Bad sdcard - rescuing"
        for i in {1..3}; do # Give this a couple of tries since it fails sometimes
            echo "Create partition table: $i"
            dd if=/dev/zero of="$SDCARD_DEVICE" bs=512 count=1024 # see comment in similar statement below
            if ! parted --script "$SDCARD_DEVICE" mklabel msdos mkpart primary 0% 100% ; then
                echo "Failed to create partition table: $i"
                continue # try again
            fi

            echo "Create exfat filesystem: $i"
            sync
            if ! mkfs.exfat "$SDCARD_PARTITION"; then
                echo "Failed to exfat filesystem: $i"
                continue # try again
            fi

            echo "Successfully restored device"
            break
        done

        # Return a specific error code so the UI can warn the user about this bad device
        exit 14 # EFAULT
    fi
fi

# Clear out the garbage bits generated by f3probe from the partition table sectors
# Otherwise parted may think we have existing partitions in a bogus state
dd if=/dev/zero of="$SDCARD_DEVICE" bs=512 count=1024

# Format as EXT4 with casefolding for proton compatibility
echo "stage=formatting"
sync
parted --script "$SDCARD_DEVICE" mklabel gpt mkpart primary 0% 100%
sync
mkfs.ext4 -m 0 -O casefold -E "$EXTENDED_OPTIONS" -F "$SDCARD_PARTITION"
sync

# Wait up until ten seconds for the new filesystem to become visible
# In some cases this can fail the first couple of times
for i in {1..10}; do
    # This doesn't help, but it also doesn't hurt.
    # The docs hint that this might be what we need so lets keep it around just in case.
    partprobe "$SDCARD_DEVICE" || true

    dev_json=$(lsblk -o FSTYPE --json -- "$SDCARD_PARTITION" | jq '.blockdevices[0]')
    ID_FS_TYPE=$(jq -r '.fstype | select(type == "string")' <<< "$dev_json")

    echo "checking fstype: attempt: ${i} fstype: ${ID_FS_TYPE}"
    if [[ ${ID_FS_TYPE} == "ext4" ]]; then
        break;
    fi

    sleep 0.5
done

# trigger the mount service
rm "$MOUNT_LOCK"
if ! systemctl start sdcard-mount@mmcblk0p1.service; then
    echo "Failed to start mount service"
    journalctl --no-pager --boot=0 -u sdcard-mount@mmcblk0p1.service
    exit 5
fi

exit 0
